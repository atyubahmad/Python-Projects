"""
    File:    jmps_and_hlts.py
    Author:  Atyub Ahmad
    Date:    10/28/21
    Description: This program will make a snakes and ladder type game

    Name: Jumping Around

    JMPs and HLTs
"""

import random

GRID_WIDTH = 8
GRID_HEIGHT = 3
DICE_SIDES = 6


def generate_random_map(length, the_seed=0):
    """
        :param length - the length of the map
        :param the_seed - the seed of the map
        :return: a randomly generated map based on a specific seed, and length.
    """
    if the_seed:
        random.seed(the_seed)
    map_list = []
    for _ in range(length - 2):
        random_points = random.randint(1, 100)
        random_position = random.randint(0, length - 1)
        map_list.append(random.choices(['nop', f'add {random_points}', f'sub {random_points}', f'mul {random_points}', f'jmp {random_position}', 'hlt'], weights=[5, 2, 2, 2, 3, 1], k=1)[0])

    return ['nop'] + map_list + ['hlt']


def make_grid(table_size):
    """
    :param table_size: this needs to be the length of the map
    :return: returns a display grid that you can then modify with fill_grid_square (it's a 2d-grid of characters)
    """
    floating_square_root = table_size ** (1 / 2)

    int_square_root = int(floating_square_root) + (1 if floating_square_root % 1 else 0)
    table_height = int_square_root
    if int_square_root * (int_square_root - 1) >= table_size:
        table_height -= 1

    the_display_grid = [[' ' if j % GRID_WIDTH else '*' for j in range(GRID_WIDTH * int_square_root + 1)]
                        if i % GRID_HEIGHT else ['*' for j in range(GRID_WIDTH * int_square_root + 1)]
                        for i in range(table_height * GRID_HEIGHT + 1)]
    return the_display_grid


def fill_grid_square(display_grid, size, index, message):
    """
    :param display_grid:  the grid that was made from make_grid
    :param size:  this needs to be the length of the total map, otherwise you may not be able to place things correctly.
    :param index: the index of the position where you want to display the message
    :param message: the message to display in the square at position index, separated by line returns.
    """
    floating_square_root = size ** (1 / 2)
    int_square_root = int(floating_square_root) + (1 if floating_square_root % 1 else 0)
    table_row = index // int_square_root
    table_col = index % int_square_root

    if table_row % 2 == 0:
        column_start = GRID_WIDTH * table_col
    else:
        column_start = GRID_WIDTH * (int_square_root - table_col - 1)

    for r, message_line in enumerate(message.split('\n')):
        for k, c in enumerate(message_line):
            display_grid[GRID_HEIGHT * table_row + 1 + r][column_start + 1 + k] = c


def roll_dice():
    """
        Call this function once per turn.

        :return: returns the dice roll
    """
    return random.randint(1, DICE_SIDES)


def init_map():
    """
        This function takes in a board size and seed from the user

        :return: returns the generated game map
    """
    user_input = input("Board size and seed: ").split()
    user_length = int(user_input[0])
    user_seed = int(user_input[1])
    game_map = generate_random_map(user_length, user_seed)
    return game_map

def init_grid():
    """
        makes the grid/board based of user inputted length and fills it with the messages at each index

        :return:
    """
    # Setting a variable to properly display a grid
    grid = make_grid(len(game_map))

    # for loop to print the grid to display everything needed
    for i in range(len(game_map)):
        fill_grid_square(grid, len(game_map), i, f'{i}\n{game_map[i]}')

    # This joins the spaces so the grid is displayed properly
    for i in range(len(grid)):
        print(''.join(grid[i]))


def play_game(game_map):
    """
        :param game_map: Passes through the list with all the messages

        :return:
    """
    # Setting all the base indexes
    user_position = 0
    user_action = "nop"
    user_score = 0

    # Setting a while loop to run the game till hlt is hit
    while user_action != "hlt":
        # Rolling the dice every turn and updating the user's position based off of it
        dice_roll = roll_dice()
        user_position += dice_roll

        # Setting a parameter so the user is not able to go off the board
        if user_position >= len(game_map):
            user_position = len(game_map) - 1

        # Setting a variable to the message at that certain index and then splitting the message into two
        user_action = game_map[user_position]
        action_parts = user_action.split()

        # Evaluating the jump command so the user position and action are updated and printing the right statement
        if action_parts[0] == "jmp":
            print("Pos:", user_position, "Score:", str(user_score) + ",", "instruction", user_action, "Rolled:",
                  dice_roll)
            user_position = int(action_parts[1])
            user_action = game_map[user_position]

        # Updating user score if math is required
        user_score = game_math(user_action, user_score)

        # Print statement for each turn
        print("Pos:", user_position, "Score:", str(user_score) + ",", "instruction", user_action, "Rolled:", dice_roll)
    # Final print statement
    print("Final Pos:", user_position, "Final Score:", str(user_score) + ",", "Instruction hlt")


def game_math(user_action, user_score):
    """
    This function handles all the game math
    :param user_action: List of all the messages like: add, sub, mult
    :param user_score: Score of the player

    :return: returns the score of a user
    """
    # Splitting the message into two, like: add 7 ---> 'add' '7'
    action_parts = user_action.split()
    # Setting a variable equal to the first index of the message
    action_command = action_parts[0]

    # Conditionals to execute the math functions needed
    if action_command == "add":
        user_score += int(action_parts[1])
    if action_command == "sub":
        user_score -= int(action_parts[1])
    if action_command == "mult":
        user_score *= int(action_parts[1])

    return user_score


if __name__ == '__main__':

    game_map = init_map()
    init_grid()
    play_game(game_map)

